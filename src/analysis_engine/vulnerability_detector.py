import re

class VulnerabilityDetector:
    def __init__(self):
        self.vulnerability_rules = {
            "virtual_machines": [
                {
                    "name": "Public IP Address",
                    "description": "Virtual machines should not have public IP addresses.",
                    "severity": "High",
                    "pattern": lambda vm: any(ip_config.get("publicIpAddress") for ip_config in vm.get("ipAddresses", []))
                },
                {
                    "name": "Open Management Ports",
                    "description": "Management ports (RDP/SSH) should not be open to the public.",
                    "severity": "High",
                    "pattern": lambda vm: any(
                        rule.get("destinationPortRange") in ["3389", "22"] and rule.get("access") == "Allow"
                        for rule in vm.get("networkSecurityGroup", {}).get("securityRules", [])
                    )
                },
                {
                    "name": "Unencrypted Disk",
                    "description": "Virtual machine disks should be encrypted.",
                    "severity": "Medium",
                    "pattern": lambda vm: not vm.get("disks", []) or not all(disk.get("encryptionSettings") for disk in vm["disks"])
                },
                {
                    "name": "Missing Endpoint Protection",
                    "description": "Virtual machines should have endpoint protection installed.",
                    "severity": "Medium",
                    "pattern": lambda vm: not vm.get("extensions", []) or not any(ext.get("type") == "MicrosoftMonitoringAgent" for ext in vm["extensions"])
                }
            ],
            "storage_accounts": [
                {
                    "name": "Public Blob Container",
                    "description": "Blob containers should not be publicly accessible.",
                    "severity": "High",
                    "pattern": lambda storage: storage.get("allowBlobPublicAccess")
                },
                {
                    "name": "Missing HTTPS",
                    "description": "Storage accounts should enforce HTTPS traffic.",
                    "severity": "Medium",
                    "pattern": lambda storage: storage.get("supportsHttpsTrafficOnly") is False
                },
                {
                    "name": "Missing Encryption",
                    "description": "Storage accounts should be encrypted with customer-managed keys.",
                    "severity": "Low",
                    "pattern": lambda storage: storage.get("encryption", {}).get("keySource") != "Microsoft.Keyvault"
                }
            ],
            "network_security_groups": [
                {
                    "name": "Overly Permissive Inbound Rule",
                    "description": "Inbound rules should be restrictive and allow only necessary traffic.",
                    "severity": "High",
                    "pattern": lambda nsg: any(
                        rule.get("access") == "Allow" and
                        rule.get("direction") == "Inbound" and
                        (rule.get("sourceAddressPrefix") == "*" or rule.get("sourceAddressPrefix") == "Internet")
                        for rule in nsg.get("securityRules", [])
                    )
                },
                {
                    "name": "Unrestricted Outbound Rule",
                    "description": "Outbound rules should be properly configured to limit outbound traffic.",
                    "severity": "Medium",
                    "pattern": lambda nsg: any(
                        rule.get("access") == "Allow" and
                        rule.get("direction") == "Outbound" and
                        (rule.get("destinationAddressPrefix") == "*" or rule.get("destinationAddressPrefix") == "Internet")
                        for rule in nsg.get("securityRules", [])
                    )
                }
            ],
            "public_ip_addresses": [
                {
                    "name": "Missing Network Security Group",
                    "description": "Public IP addresses should be associated with a network security group.",
                    "severity": "High",
                    "pattern": lambda public_ip: not public_ip.get("networkSecurityGroup")
                }
            ],
            "virtual_networks": [
                {
                    "name": "Broad Address Space",
                    "description": "Virtual networks should have a specific and limited address space.",
                    "severity": "Low",
                    "pattern": lambda vnet: any(
                        address_prefix.startswith("10.0.0.0") or
                        address_prefix.startswith("172.16.0.0") or
                        address_prefix.startswith("192.168.0.0")
                        for address_prefix in vnet.get("addressSpace", {}).get("addressPrefixes", [])
                    )
                },
                {
                    "name": "Unrestricted Peering",
                    "description": "Virtual network peerings should be restricted and properly configured.",
                    "severity": "Medium",
                    "pattern": lambda vnet: any(
                        peering.get("allowVirtualNetworkAccess") and
                        peering.get("allowForwardedTraffic") and
                        peering.get("allowGatewayTransit")
                        for peering in vnet.get("virtualNetworkPeerings", [])
                    )
                }
            ],
            "azure_active_directory": [
                {
                    "name": "Disabled User Account",
                    "description": "User accounts should be enabled and active.",
                    "severity": "Low",
                    "resource_type": "users",
                    "pattern": lambda user: not user.get("accountEnabled")
                },
                {
                    "name": "Guest User Account",
                    "description": "Guest user accounts should be regularly reviewed and removed when no longer needed.",
                    "severity": "Medium",
                    "resource_type": "users",
                    "pattern": lambda user: user.get("userType") == "Guest"
                },
                {
                    "name": "Non-Security-Enabled Group",
                    "description": "Groups should be security-enabled to enforce access controls.",
                    "severity": "Low",
                    "resource_type": "groups",
                    "pattern": lambda group: group.get("securityEnabled") is False
                },
                {
                    "name": "Elevated Role Assignment",
                    "description": "Privileged roles should be assigned with caution and regularly reviewed.",
                    "severity": "High",
                    "resource_type": "role_assignments",
                    "pattern": lambda assignment: assignment["roleDefinitionName"] == "Owner"
                },
                {
                    "name": "Disabled Service Principal",
                    "description": "Service principals should be enabled and actively used.",
                    "severity": "Low",
                    "resource_type": "service_principals",
                    "pattern": lambda sp: sp.get("accountEnabled") is False
                },
                {
                    "name": "Non-Microsoft-Published App",
                    "description": "Apps should be published by trusted publishers, preferably Microsoft.",
                    "severity": "Medium",
                    "resource_type": "app_registrations",
                    "pattern": lambda app: app.get("publisherDomain") != "microsoft.com"
                },
                {
                    "name": "Disabled Conditional Access Policy",
                    "description": "Conditional access policies should be enabled to enforce access controls.",
                    "severity": "Medium",
                    "resource_type": "conditional_access_policies",
                    "pattern": lambda policy: policy.get("state") != "enabled"
                }
            ],
            "azure_security_center": [
                {
                    "name": "Disabled Security Policy",
                    "description": "Security policies should be enabled to ensure proper security monitoring.",
                    "severity": "High",
                    "resource_type": "security_policies",
                    "pattern": lambda policy: policy.get("state") != "Enabled"
                },
                {
                    "name": "Unhealthy Security Recommendation",
                    "description": "Security recommendations should be addressed to improve the security posture.",
                    "severity": "Medium",
                    "resource_type": "security_recommendations",
                    "pattern": lambda recommendation: recommendation.get("status") != "Healthy"
                },
                {
                    "name": "Unresolved Security Alert",
                    "description": "Security alerts should be investigated and resolved promptly.",
                    "severity": "High",
                    "resource_type": "security_alerts",
                    "pattern": lambda alert: alert.get("status") != "Resolved"
                },
                {
                    "name": "Unhealthy Compliance Result",
                    "description": "Compliance results should be healthy to meet security standards.",
                    "severity": "Medium",
                    "resource_type": "compliance_results",
                    "pattern": lambda result: result.get("resourceStatus") != "Healthy"
                },
                {
                    "name": "Failed Regulatory Compliance Standard",
                    "description": "Regulatory compliance standards should be met to ensure security and compliance.",
                    "severity": "High",
                    "resource_type": "regulatory_compliance_standards",
                    "pattern": lambda standard: standard.get("state") != "Passed"
                },
                {
                    "name": "Low Secure Score",
                    "description": "The secure score should be improved to enhance the overall security posture.",
                    "severity": "Low",
                    "resource_type": "secure_scores",
                    "pattern": lambda score: score.get("score", {}).get("current") < score.get("score", {}).get("max")
                },
                {
                    "name": "Disabled Automation Setting",
                    "description": "Automation settings should be enabled to automate security tasks and responses.",
                    "severity": "Medium",
                    "resource_type": "automation_settings",
                    "pattern": lambda setting: setting.get("enabled") is False
                }
            ],
            "azure_monitor": [
                {
                    "name": "Disabled Metric",
                    "description": "Metrics should be enabled to monitor resource performance and health.",
                    "severity": "Low",
                    "resource_type": "metrics",
                    "pattern": lambda metric: not metric.get("enabled")
                },
                {
                    "name": "Missing Diagnostic Setting",
                    "description": "Diagnostic settings should be configured to capture resource logs and metrics.",
                    "severity": "Medium",
                    "resource_type": "diagnostic_settings",
                    "pattern": lambda setting: not setting.get("storageAccountId") and not setting.get("workspaceId")
                },
                {
                    "name": "Disabled Log Profile",
                    "description": "Log profiles should be enabled to centrally collect and analyze logs.",
                    "severity": "Medium",
                    "resource_type": "log_profiles",
                    "pattern": lambda profile: not profile.get("retentionPolicy", {}).get("enabled")
                },
                {
                    "name": "Disabled Action Group",
                    "description": "Action groups should be enabled to define actions and notifications for alerts.",
                    "severity": "Medium",
                    "resource_type": "action_groups",
                    "pattern": lambda group: not group.get("enabled")
                },
                {
                    "name": "Disabled Autoscale Setting",
                    "description": "Autoscale settings should be enabled to automatically adjust resource capacity.",
                    "severity": "Low",
                    "resource_type": "autoscale_settings",
                    "pattern": lambda setting: not setting.get("enabled")
                },
                {
                    "name": "Disabled Alert Rule",
                    "description": "Alert rules should be enabled to detect and notify about critical conditions.",
                    "severity": "High",
                    "resource_type": "alert_rules",
                    "pattern": lambda rule: rule.get("enabled") is False
                },
                {
                    "name": "Public Application Insights Component",
                    "description": "Application Insights components should have restricted public access.",
                    "severity": "Medium",
                    "resource_type": "app_insights_components",
                    "pattern": lambda component: component.get("publicNetworkAccessForIngestion") != "Disabled" or component.get("publicNetworkAccessForQuery") != "Disabled"
                },
                {
                    "name": "Short Log Analytics Retention",
                    "description": "Log Analytics workspaces should have a sufficient retention period for log analysis.",
                    "severity": "Medium",
                    "resource_type": "log_analytics_workspaces",
                    "pattern": lambda workspace: workspace.get("retentionInDays") < 30
                }
            ]
        }

    def detect_vulnerabilities(self, aggregated_data, security_findings):
        vulnerabilities = []

        for resource_type, rules in self.vulnerability_rules.items():
            for rule in rules:
                if resource_type in ["azure_active_directory", "azure_security_center", "azure_monitor"]:
                    for resource in aggregated_data[resource_type][rule["resource_type"]]:
                        if rule["pattern"](resource):
                            vulnerability = {
                                "resource_type": resource_type.capitalize().replace("_", " "),
                                "resource_name": resource.get("name") or resource.get("displayName") or resource.get("id"),
                                "name": rule["name"],
                                "description": rule["description"],
                                "severity": rule["severity"]
                            }
                            vulnerabilities.append(vulnerability)
                else:
                    for resource in aggregated_data[resource_type]:
                        if rule["pattern"](resource):
                            vulnerability = {
                                "resource_type": resource_type.capitalize().replace("_", " "),
                                "resource_name": resource["name"],
                                "name": rule["name"],
                                "description": rule["description"],
                                "severity": rule["severity"]
                            }
                            vulnerabilities.append(vulnerability)

        vulnerabilities.extend(self.detect_security_findings_vulnerabilities(security_findings))

        return vulnerabilities

    def detect_security_findings_vulnerabilities(self, security_findings):
        vulnerabilities = []

        for resource_type, findings in security_findings.items():
            if isinstance(findings, dict):
                for sub_resource_type, sub_findings in findings.items():
                    for finding in sub_findings:
                        vulnerability = {
                            "resource_type": resource_type.capitalize().replace("_", " "),
                            "resource_name": finding.get("resource_name"),
                            "name": finding["issue"],
                            "description": finding["issue"],
                            "severity": finding["severity"]
                        }
                        vulnerabilities.append(vulnerability)
            else:
                for finding in findings:
                    vulnerability = {
                        "resource_type": resource_type.capitalize().replace("_", " "),
                        "resource_name": finding.get("resource_name"),
                        "name": finding["issue"],
                        "description": finding["issue"],
                        "severity": finding["severity"]
                    }
                    vulnerabilities.append(vulnerability)

        return vulnerabilities